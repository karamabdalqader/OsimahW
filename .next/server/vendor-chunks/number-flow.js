"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/number-flow";
exports.ids = ["vendor-chunks/number-flow"];
exports.modules = {

/***/ "(ssr)/./node_modules/number-flow/dist/lite-BTIaQdTe.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/number-flow/dist/lite-BTIaQdTe.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ D),\n/* harmony export */   N: () => (/* binding */ J),\n/* harmony export */   S: () => (/* binding */ G),\n/* harmony export */   c: () => (/* binding */ q),\n/* harmony export */   d: () => (/* binding */ st),\n/* harmony export */   f: () => (/* binding */ nt),\n/* harmony export */   p: () => (/* binding */ A),\n/* harmony export */   r: () => (/* binding */ at)\n/* harmony export */ });\n/* harmony import */ var esm_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! esm-env */ \"(ssr)/./node_modules/esm-env/index.js\");\n/* harmony import */ var _plugins_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins.mjs */ \"(ssr)/./node_modules/number-flow/dist/plugins.mjs\");\n\n\nconst u = (n, t, e) => {\n  const i = document.createElement(n), [s, a] = Array.isArray(t) ? [void 0, t] : [t, e];\n  return s && Object.assign(i, s), a == null || a.forEach((r) => i.appendChild(r)), i;\n}, F = (n, t) => {\n  var e;\n  return t === \"left\" ? n.offsetLeft : (((e = n.offsetParent instanceof HTMLElement ? n.offsetParent : null) == null ? void 0 : e.offsetWidth) ?? 0) - n.offsetWidth - n.offsetLeft;\n}, H = (n) => n.offsetWidth > 0 && n.offsetHeight > 0, st = (n, t) => {\n  esm_env__WEBPACK_IMPORTED_MODULE_0__.BROWSER && !customElements.get(n) && customElements.define(n, t);\n};\nfunction X(n, t, { reverse: e = !1 } = {}) {\n  const i = n.length;\n  for (let s = e ? i - 1 : 0; e ? s >= 0 : s < i; e ? s-- : s++)\n    t(n[s], s);\n}\nfunction nt(n, t, e, i) {\n  const s = t.formatToParts(n);\n  e && s.unshift({ type: \"prefix\", value: e }), i && s.push({ type: \"suffix\", value: i });\n  const a = [], r = [], o = [], c = [], d = {}, p = (h) => `${h}:${d[h] = (d[h] ?? -1) + 1}`;\n  let x = \"\", g = !1, y = !1;\n  for (const h of s) {\n    x += h.value;\n    const l = h.type === \"minusSign\" || h.type === \"plusSign\" ? \"sign\" : h.type;\n    l === \"integer\" ? (g = !0, r.push(...h.value.split(\"\").map((C) => ({ type: l, value: parseInt(C) })))) : l === \"group\" ? r.push({ type: l, value: h.value }) : l === \"decimal\" ? (y = !0, o.push({ type: l, value: h.value, key: p(l) })) : l === \"fraction\" ? o.push(...h.value.split(\"\").map((C) => ({\n      type: l,\n      value: parseInt(C),\n      key: p(l),\n      pos: -1 - d[l]\n    }))) : (g || y ? c : a).push({\n      type: l,\n      value: h.value,\n      key: p(l)\n    });\n  }\n  const T = [];\n  for (let h = r.length - 1; h >= 0; h--) {\n    const l = r[h];\n    T.unshift(l.type === \"integer\" ? {\n      ...l,\n      key: p(l.type),\n      pos: d[l.type]\n    } : {\n      ...l,\n      key: p(l.type)\n    });\n  }\n  return {\n    pre: a,\n    integer: T,\n    fraction: o,\n    post: c,\n    valueAsString: x,\n    value: typeof n == \"string\" ? parseFloat(n) : n\n  };\n}\nconst I = String.raw, V = String.raw, O = esm_env__WEBPACK_IMPORTED_MODULE_0__.BROWSER && (() => {\n  try {\n    document.createElement(\"div\").animate({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n  } catch {\n    return !1;\n  }\n  return !0;\n})(), z = esm_env__WEBPACK_IMPORTED_MODULE_0__.BROWSER && typeof CSS < \"u\" && CSS.supports && CSS.supports(\"line-height\", \"mod(1,1)\"), A = esm_env__WEBPACK_IMPORTED_MODULE_0__.BROWSER && typeof matchMedia < \"u\" ? matchMedia(\"(prefers-reduced-motion: reduce)\") : null, $ = \"--_number-flow-d-opacity\", U = \"--_number-flow-d-width\", S = \"--_number-flow-dx\", j = \"--_number-flow-d\", Y = (() => {\n  try {\n    return CSS.registerProperty({\n      name: $,\n      syntax: \"<number>\",\n      inherits: !1,\n      initialValue: \"0\"\n    }), CSS.registerProperty({\n      name: S,\n      syntax: \"<length>\",\n      inherits: !0,\n      initialValue: \"0px\"\n    }), CSS.registerProperty({\n      name: U,\n      syntax: \"<number>\",\n      inherits: !1,\n      initialValue: \"0\"\n    }), CSS.registerProperty({\n      name: j,\n      syntax: \"<number>\",\n      inherits: !0,\n      initialValue: \"0\"\n    }), !0;\n  } catch {\n    return !1;\n  }\n})(), P = \"var(--number-flow-char-height, 1em)\", f = \"var(--number-flow-mask-height, 0.25em)\", k = `calc(${f} / 2)`, E = \"var(--number-flow-mask-width, 0.5em)\", m = `calc(${E} / var(--scale-x))`, w = \"#000 0, transparent 71%\", M = V`:host{display:inline-block;direction:ltr;white-space:nowrap;isolation:isolate;line-height:${P} !important}.number,.number__inner{display:inline-block;transform-origin:left top}:host([data-will-change]) :is(.number,.number__inner,.section,.digit,.digit__num,.symbol){will-change:transform}.number{--scale-x:calc(1 + var(${U}) / var(--width));transform:translateX(var(${S})) scaleX(var(--scale-x));margin:0 calc(-1 * ${E});position:relative;-webkit-mask-image:linear-gradient(to right,transparent 0,#000 ${m},#000 calc(100% - ${m}),transparent ),linear-gradient(to bottom,transparent 0,#000 ${f},#000 calc(100% - ${f}),transparent 100% ),radial-gradient(at bottom right,${w}),radial-gradient(at bottom left,${w}),radial-gradient(at top left,${w}),radial-gradient(at top right,${w});-webkit-mask-size:100% calc(100% - ${f} * 2),calc(100% - ${m} * 2) 100%,${m} ${f},${m} ${f},${m} ${f},${m} ${f};-webkit-mask-position:center,center,top left,top right,bottom right,bottom left;-webkit-mask-repeat:no-repeat}.number__inner{padding:${k} ${E};transform:scaleX(calc(1 / var(--scale-x))) translateX(calc(-1 * var(${S})))}:host > :not(.number){z-index:5}.section,.symbol{display:inline-block;position:relative;isolation:isolate}.section::after{content:'\\200b';display:inline-block}.section--justify-left{transform-origin:center left}.section--justify-right{transform-origin:center right}.section > [inert],.symbol > [inert]{margin:0 !important;position:absolute !important;z-index:-1}.digit{display:inline-block;position:relative;--c:var(--current) + var(${j})}.digit__num,.number .section::after{padding:${k} 0}.digit__num{display:inline-block;--offset-raw:mod(var(--length) + var(--n) - mod(var(--c),var(--length)),var(--length));--offset:calc( var(--offset-raw) - var(--length) * round(down,var(--offset-raw) / (var(--length) / 2),1) );--y:clamp(-100%,var(--offset) * 100%,100%);transform:translateY(var(--y))}.digit__num[inert]{position:absolute;top:0;left:50%;transform:translateX(-50%) translateY(var(--y))}.digit:not(.is-spinning) .digit__num[inert]{display:none}.symbol__value{display:inline-block;mix-blend-mode:plus-lighter;white-space:pre}.section--justify-left .symbol > [inert]{left:0}.section--justify-right .symbol > [inert]{right:0}.animate-presence{opacity:calc(1 + var(${$}))}`, G = esm_env__WEBPACK_IMPORTED_MODULE_0__.BROWSER ? HTMLElement : class {\n}, K = V`:host{display:inline-block;direction:ltr;white-space:nowrap;line-height:${P} !important}span{display:inline-block}:host([data-will-change]) span{will-change:transform}.number,.digit{padding:${k} 0}.symbol{white-space:pre}`, Z = (n) => `<span class=\"${n.type === \"integer\" || n.type === \"fraction\" ? \"digit\" : \"symbol\"}\" part=\"${n.type === \"integer\" || n.type === \"fraction\" ? `digit ${n.type}-digit` : `symbol ${n.type}`}\">${n.value}</span>`, v = (n, t) => `<span part=\"${t}\">${n.reduce((e, i) => e + Z(i), \"\")}</span>`, at = (n) => (\n  // shadowroot=\"open\" non-standard attribute for old Chrome:\n  I`<template shadowroot=\"open\" shadowrootmode=\"open\"\n\t\t\t><style>\n\t\t\t\t${K}</style\n\t\t\t><span role=\"img\" aria-label=\"${n.valueAsString}\"\n\t\t\t\t>${v(n.pre, \"left\")}<span part=\"number\" class=\"number\"\n\t\t\t\t\t>${v(n.integer, \"integer\")}${v(n.fraction, \"fraction\")}</span\n\t\t\t\t>${v(n.post, \"right\")}</span\n\t\t\t></template\n\t\t><span\n\t\t\tstyle=\"font-kerning: none; display: inline-block; line-height: ${P} !important; padding: ${f} 0;\"\n\t\t\t>${n.valueAsString}</span\n\t\t>`\n), q = z && O && Y;\nlet b;\nclass J extends G {\n  constructor() {\n    super(), this.created = !1, this.batched = !1;\n    const { animated: t, ...e } = this.constructor.defaultProps;\n    this._animated = this.computedAnimated = t, Object.assign(this, e);\n  }\n  get animated() {\n    return this._animated;\n  }\n  set animated(t) {\n    var e;\n    this.animated !== t && (this._animated = t, (e = this.shadowRoot) == null || e.getAnimations().forEach((i) => i.finish()));\n  }\n  /**\n   * @internal\n   */\n  set data(t) {\n    var o;\n    if (t == null)\n      return;\n    const { pre: e, integer: i, fraction: s, post: a, value: r } = t;\n    if (this.created) {\n      const c = this._data;\n      this._data = t, this.computedTrend = typeof this.trend == \"function\" ? this.trend(c.value, r) : this.trend, this.computedAnimated = q && this._animated && (!this.respectMotionPreference || !(A != null && A.matches)) && // https://github.com/barvian/number-flow/issues/9\n      H(this), (o = this.plugins) == null || o.forEach((d) => {\n        var p;\n        return (p = d.onUpdate) == null ? void 0 : p.call(d, t, c, this);\n      }), this.batched || this.willUpdate(), this._pre.update(e), this._num.update({ integer: i, fraction: s }), this._post.update(a), this.batched || this.didUpdate();\n    } else {\n      this._data = t, this.attachShadow({ mode: \"open\" });\n      try {\n        this._internals ?? (this._internals = this.attachInternals()), this._internals.role = \"img\";\n      } catch {\n      }\n      if (typeof CSSStyleSheet < \"u\" && this.shadowRoot.adoptedStyleSheets)\n        b || (b = new CSSStyleSheet(), b.replaceSync(M)), this.shadowRoot.adoptedStyleSheets = [b];\n      else {\n        const c = document.createElement(\"style\");\n        c.textContent = M, this.shadowRoot.appendChild(c);\n      }\n      this._pre = new N(this, e, {\n        justify: \"right\",\n        part: \"left\"\n      }), this.shadowRoot.appendChild(this._pre.el), this._num = new Q(this, i, s), this.shadowRoot.appendChild(this._num.el), this._post = new N(this, a, {\n        justify: \"left\",\n        part: \"right\"\n      }), this.shadowRoot.appendChild(this._post.el), this.created = !0;\n    }\n    try {\n      this._internals.ariaLabel = t.valueAsString;\n    } catch {\n    }\n  }\n  /**\n   * @internal\n   */\n  willUpdate() {\n    this._pre.willUpdate(), this._num.willUpdate(), this._post.willUpdate();\n  }\n  /**\n   * @internal\n   */\n  didUpdate() {\n    if (!this.computedAnimated)\n      return;\n    this._abortAnimationsFinish ? this._abortAnimationsFinish.abort() : this.dispatchEvent(new Event(\"animationsstart\")), this._pre.didUpdate(), this._num.didUpdate(), this._post.didUpdate();\n    const t = new AbortController();\n    Promise.all(this.shadowRoot.getAnimations().map((e) => e.finished)).then(() => {\n      t.signal.aborted || (this.dispatchEvent(new Event(\"animationsfinish\")), this._abortAnimationsFinish = void 0);\n    }), this._abortAnimationsFinish = t;\n  }\n}\nJ.defaultProps = {\n  transformTiming: {\n    duration: 900,\n    // Make sure to keep this minified:\n    easing: \"linear(0,.005,.019,.039,.066,.096,.129,.165,.202,.24,.278,.316,.354,.39,.426,.461,.494,.526,.557,.586,.614,.64,.665,.689,.711,.731,.751,.769,.786,.802,.817,.831,.844,.856,.867,.877,.887,.896,.904,.912,.919,.925,.931,.937,.942,.947,.951,.955,.959,.962,.965,.968,.971,.973,.976,.978,.98,.981,.983,.984,.986,.987,.988,.989,.99,.991,.992,.992,.993,.994,.994,.995,.995,.996,.996,.9963,.9967,.9969,.9972,.9975,.9977,.9979,.9981,.9982,.9984,.9985,.9987,.9988,.9989,1)\"\n  },\n  spinTiming: void 0,\n  opacityTiming: { duration: 450, easing: \"ease-out\" },\n  animated: !0,\n  trend: (n, t) => Math.sign(t - n),\n  respectMotionPreference: !0,\n  plugins: void 0,\n  digits: void 0\n};\nclass Q {\n  constructor(t, e, i, { className: s, ...a } = {}) {\n    this.flow = t, this._integer = new L(t, e, {\n      justify: \"right\",\n      part: \"integer\"\n    }), this._fraction = new L(t, i, {\n      justify: \"left\",\n      part: \"fraction\"\n    }), this._inner = u(\"span\", {\n      className: \"number__inner\"\n    }, [this._integer.el, this._fraction.el]), this.el = u(\"span\", {\n      ...a,\n      part: \"number\",\n      className: `number ${s ?? \"\"}`\n    }, [this._inner]);\n  }\n  willUpdate() {\n    this._prevWidth = this.el.offsetWidth, this._prevLeft = this.el.getBoundingClientRect().left, this._integer.willUpdate(), this._fraction.willUpdate();\n  }\n  update({ integer: t, fraction: e }) {\n    this._integer.update(t), this._fraction.update(e);\n  }\n  didUpdate() {\n    const t = this.el.getBoundingClientRect();\n    this._integer.didUpdate(), this._fraction.didUpdate();\n    const e = this._prevLeft - t.left, i = this.el.offsetWidth, s = this._prevWidth - i;\n    this.el.style.setProperty(\"--width\", String(i)), this.el.animate({\n      [S]: [`${e}px`, \"0px\"],\n      [U]: [s, 0]\n    }, {\n      ...this.flow.transformTiming,\n      composite: \"accumulate\"\n    });\n  }\n}\nclass W {\n  constructor(t, e, { justify: i, className: s, ...a }, r) {\n    this.flow = t, this.children = /* @__PURE__ */ new Map(), this.onCharRemove = (c) => () => {\n      this.children.delete(c);\n    }, this.justify = i;\n    const o = e.map((c) => this.addChar(c).el);\n    this.el = u(\"span\", {\n      ...a,\n      className: `section section--justify-${i} ${s ?? \"\"}`\n    }, r ? r(o) : o);\n  }\n  addChar(t, { startDigitsAtZero: e = !1, ...i } = {}) {\n    const s = t.type === \"integer\" || t.type === \"fraction\" ? new D(this, t.type, e ? 0 : t.value, t.pos, {\n      ...i,\n      onRemove: this.onCharRemove(t.key)\n    }) : new tt(this, t.type, t.value, {\n      ...i,\n      onRemove: this.onCharRemove(t.key)\n    });\n    return this.children.set(t.key, s), s;\n  }\n  unpop(t) {\n    t.el.removeAttribute(\"inert\"), t.el.style.top = \"\", t.el.style[this.justify] = \"\";\n  }\n  pop(t) {\n    t.forEach((e) => {\n      e.el.style.top = `${e.el.offsetTop}px`, e.el.style[this.justify] = `${F(e.el, this.justify)}px`;\n    }), t.forEach((e) => {\n      e.el.setAttribute(\"inert\", \"\"), e.present = !1;\n    });\n  }\n  addNewAndUpdateExisting(t) {\n    const e = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = this.justify === \"left\", a = s ? \"prepend\" : \"append\";\n    if (X(t, (r) => {\n      let o;\n      this.children.has(r.key) ? (o = this.children.get(r.key), i.set(r, o), this.unpop(o), o.present = !0) : (o = this.addChar(r, { startDigitsAtZero: !0, animateIn: !0 }), e.set(r, o)), this.el[a](o.el);\n    }, { reverse: s }), this.flow.computedAnimated) {\n      const r = this.el.getBoundingClientRect();\n      e.forEach((o) => {\n        o.willUpdate(r);\n      });\n    }\n    e.forEach((r, o) => {\n      r.update(o.value);\n    }), i.forEach((r, o) => {\n      r.update(o.value);\n    });\n  }\n  willUpdate() {\n    const t = this.el.getBoundingClientRect();\n    this._prevOffset = t[this.justify], this.children.forEach((e) => e.willUpdate(t));\n  }\n  didUpdate() {\n    const t = this.el.getBoundingClientRect();\n    this.children.forEach((s) => s.didUpdate(t));\n    const e = t[this.justify], i = this._prevOffset - e;\n    i && this.children.size && this.el.animate({\n      transform: [`translateX(${i}px)`, \"none\"]\n    }, {\n      ...this.flow.transformTiming,\n      composite: \"accumulate\"\n    });\n  }\n}\nclass L extends W {\n  update(t) {\n    const e = /* @__PURE__ */ new Map();\n    this.children.forEach((i, s) => {\n      t.find((a) => a.key === s) || e.set(s, i), this.unpop(i);\n    }), this.addNewAndUpdateExisting(t), e.forEach((i) => {\n      i instanceof D && i.update(0);\n    }), this.pop(e);\n  }\n}\nclass N extends W {\n  update(t) {\n    const e = /* @__PURE__ */ new Map();\n    this.children.forEach((i, s) => {\n      t.find((a) => a.key === s) || e.set(s, i);\n    }), this.pop(e), this.addNewAndUpdateExisting(t);\n  }\n}\nclass R {\n  constructor(t, e, { onRemove: i, animateIn: s = !1 } = {}) {\n    this.flow = t, this.el = e, this._present = !0, this._remove = () => {\n      var a;\n      this.el.remove(), (a = this._onRemove) == null || a.call(this);\n    }, this.el.classList.add(\"animate-presence\"), this.flow.computedAnimated && s && this.el.animate({\n      [$]: [-0.9999, 0]\n    }, {\n      ...this.flow.opacityTiming,\n      composite: \"accumulate\"\n    }), this._onRemove = i;\n  }\n  get present() {\n    return this._present;\n  }\n  set present(t) {\n    if (this._present !== t) {\n      if (this._present = t, t ? this.el.removeAttribute(\"inert\") : this.el.setAttribute(\"inert\", \"\"), !this.flow.computedAnimated) {\n        t || this._remove();\n        return;\n      }\n      this.el.style.setProperty(\"--_number-flow-d-opacity\", t ? \"0\" : \"-.999\"), this.el.animate({\n        [$]: t ? [-0.9999, 0] : [0.999, 0]\n      }, {\n        ...this.flow.opacityTiming,\n        composite: \"accumulate\"\n      }), t ? this.flow.removeEventListener(\"animationsfinish\", this._remove) : this.flow.addEventListener(\"animationsfinish\", this._remove, {\n        once: !0\n      });\n    }\n  }\n}\nclass B extends R {\n  constructor(t, e, i, s) {\n    super(t.flow, i, s), this.section = t, this.value = e, this.el = i;\n  }\n}\nclass D extends B {\n  constructor(t, e, i, s, a) {\n    var d, p;\n    const r = (((p = (d = t.flow.digits) == null ? void 0 : d[s]) == null ? void 0 : p.max) ?? 9) + 1, o = Array.from({ length: r }).map((x, g) => {\n      const y = u(\"span\", { className: \"digit__num\" }, [\n        document.createTextNode(String(g))\n      ]);\n      return g !== i && y.setAttribute(\"inert\", \"\"), y.style.setProperty(\"--n\", String(g)), y;\n    }), c = u(\"span\", {\n      part: `digit ${e}-digit`,\n      className: \"digit\"\n    }, o);\n    c.style.setProperty(\"--current\", String(i)), c.style.setProperty(\"--length\", String(r)), super(t, i, c, a), this.pos = s, this._onAnimationsFinish = () => {\n      this.el.classList.remove(\"is-spinning\");\n    }, this._numbers = o, this.length = r;\n  }\n  willUpdate(t) {\n    const e = this.el.getBoundingClientRect();\n    this._prevValue = this.value;\n    const i = e[this.section.justify] - t[this.section.justify], s = e.width / 2;\n    this._prevCenter = this.section.justify === \"left\" ? i + s : i - s;\n  }\n  update(t) {\n    this.el.style.setProperty(\"--current\", String(t)), this._numbers.forEach((e, i) => i === t ? e.removeAttribute(\"inert\") : e.setAttribute(\"inert\", \"\")), this.value = t;\n  }\n  didUpdate(t) {\n    const e = this.el.getBoundingClientRect(), i = e[this.section.justify] - t[this.section.justify], s = e.width / 2, a = this.section.justify === \"left\" ? i + s : i - s, r = this._prevCenter - a;\n    r && this.el.animate({\n      transform: [`translateX(${r}px)`, \"none\"]\n    }, {\n      ...this.flow.transformTiming,\n      composite: \"accumulate\"\n    });\n    const o = this.getDelta();\n    o && (this.el.classList.add(\"is-spinning\"), this.el.animate({\n      [j]: [-o, 0]\n    }, {\n      ...this.flow.spinTiming ?? this.flow.transformTiming,\n      composite: \"accumulate\"\n    }), this.flow.addEventListener(\"animationsfinish\", this._onAnimationsFinish, { once: !0 }));\n  }\n  getDelta() {\n    var i;\n    if (this.flow.plugins)\n      for (const s of this.flow.plugins) {\n        const a = (i = s.getDelta) == null ? void 0 : i.call(s, this.value, this._prevValue, this);\n        if (a != null)\n          return a;\n      }\n    const t = this.value - this._prevValue, e = this.flow.computedTrend || Math.sign(t);\n    return e < 0 && this.value > this._prevValue ? this.value - this.length - this._prevValue : e > 0 && this.value < this._prevValue ? this.length - this._prevValue + this.value : t;\n  }\n}\nclass tt extends B {\n  constructor(t, e, i, s) {\n    const a = u(\"span\", {\n      className: \"symbol__value\",\n      textContent: i\n    });\n    super(t, i, u(\"span\", {\n      part: `symbol ${e}`,\n      className: \"symbol\"\n    }, [a]), s), this.type = e, this._children = /* @__PURE__ */ new Map(), this._onChildRemove = (r) => () => {\n      this._children.delete(r);\n    }, this._children.set(i, new R(this.flow, a, {\n      onRemove: this._onChildRemove(i)\n    }));\n  }\n  willUpdate(t) {\n    if (this.type === \"decimal\")\n      return;\n    const e = this.el.getBoundingClientRect();\n    this._prevOffset = e[this.section.justify] - t[this.section.justify];\n  }\n  update(t) {\n    if (this.value !== t) {\n      const e = this._children.get(this.value);\n      e && (e.present = !1);\n      const i = this._children.get(t);\n      if (i)\n        i.present = !0;\n      else {\n        const s = u(\"span\", {\n          className: \"symbol__value\",\n          textContent: t\n        });\n        this.el.appendChild(s), this._children.set(t, new R(this.flow, s, {\n          animateIn: !0,\n          onRemove: this._onChildRemove(t)\n        }));\n      }\n    }\n    this.value = t;\n  }\n  didUpdate(t) {\n    if (this.type === \"decimal\")\n      return;\n    const i = this.el.getBoundingClientRect()[this.section.justify] - t[this.section.justify], s = this._prevOffset - i;\n    s && this.el.animate({\n      transform: [`translateX(${s}px)`, \"none\"]\n    }, { ...this.flow.transformTiming, composite: \"accumulate\" });\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnVtYmVyLWZsb3cvZGlzdC9saXRlLUJUSWFRZFRlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ2hCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELEVBQUUsNENBQUM7QUFDSDtBQUNBLG1CQUFtQixrQkFBa0IsSUFBSTtBQUN6QztBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCLGlCQUFpQiwwQkFBMEI7QUFDeEYsOENBQThDLGdCQUFnQixFQUFFLEdBQUcsd0JBQXdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDZCQUE2QixnQ0FBZ0MseUJBQXlCLHdDQUF3QyxvQ0FBb0M7QUFDM087QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNENBQUM7QUFDM0M7QUFDQSw0Q0FBNEMsWUFBWSxJQUFJLHdCQUF3QjtBQUNwRixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTLDRDQUFDLHFGQUFxRiw0Q0FBQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDLDBHQUEwRyxHQUFHLCtEQUErRCxHQUFHLCtEQUErRCxxQkFBcUIsY0FBYyxtQkFB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QUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCxXQUFXO0FBQ25JLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixFQUFFO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRTtBQUNsQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssOEVBQThFLFVBQVU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLEVBQUU7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRTtBQUNsQyxLQUFLLElBQUksdURBQXVEO0FBQ2hFO0FBQ0E7QUFVRSIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvbnVtYmVyLWZsb3cvZGlzdC9saXRlLUJUSWFRZFRlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCUk9XU0VSIGFzIF8gfSBmcm9tIFwiZXNtLWVudlwiO1xuaW1wb3J0IFwiLi9wbHVnaW5zLm1qc1wiO1xuY29uc3QgdSA9IChuLCB0LCBlKSA9PiB7XG4gIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG4pLCBbcywgYV0gPSBBcnJheS5pc0FycmF5KHQpID8gW3ZvaWQgMCwgdF0gOiBbdCwgZV07XG4gIHJldHVybiBzICYmIE9iamVjdC5hc3NpZ24oaSwgcyksIGEgPT0gbnVsbCB8fCBhLmZvckVhY2goKHIpID0+IGkuYXBwZW5kQ2hpbGQocikpLCBpO1xufSwgRiA9IChuLCB0KSA9PiB7XG4gIHZhciBlO1xuICByZXR1cm4gdCA9PT0gXCJsZWZ0XCIgPyBuLm9mZnNldExlZnQgOiAoKChlID0gbi5vZmZzZXRQYXJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IG4ub2Zmc2V0UGFyZW50IDogbnVsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IGUub2Zmc2V0V2lkdGgpID8/IDApIC0gbi5vZmZzZXRXaWR0aCAtIG4ub2Zmc2V0TGVmdDtcbn0sIEggPSAobikgPT4gbi5vZmZzZXRXaWR0aCA+IDAgJiYgbi5vZmZzZXRIZWlnaHQgPiAwLCBzdCA9IChuLCB0KSA9PiB7XG4gIF8gJiYgIWN1c3RvbUVsZW1lbnRzLmdldChuKSAmJiBjdXN0b21FbGVtZW50cy5kZWZpbmUobiwgdCk7XG59O1xuZnVuY3Rpb24gWChuLCB0LCB7IHJldmVyc2U6IGUgPSAhMSB9ID0ge30pIHtcbiAgY29uc3QgaSA9IG4ubGVuZ3RoO1xuICBmb3IgKGxldCBzID0gZSA/IGkgLSAxIDogMDsgZSA/IHMgPj0gMCA6IHMgPCBpOyBlID8gcy0tIDogcysrKVxuICAgIHQobltzXSwgcyk7XG59XG5mdW5jdGlvbiBudChuLCB0LCBlLCBpKSB7XG4gIGNvbnN0IHMgPSB0LmZvcm1hdFRvUGFydHMobik7XG4gIGUgJiYgcy51bnNoaWZ0KHsgdHlwZTogXCJwcmVmaXhcIiwgdmFsdWU6IGUgfSksIGkgJiYgcy5wdXNoKHsgdHlwZTogXCJzdWZmaXhcIiwgdmFsdWU6IGkgfSk7XG4gIGNvbnN0IGEgPSBbXSwgciA9IFtdLCBvID0gW10sIGMgPSBbXSwgZCA9IHt9LCBwID0gKGgpID0+IGAke2h9OiR7ZFtoXSA9IChkW2hdID8/IC0xKSArIDF9YDtcbiAgbGV0IHggPSBcIlwiLCBnID0gITEsIHkgPSAhMTtcbiAgZm9yIChjb25zdCBoIG9mIHMpIHtcbiAgICB4ICs9IGgudmFsdWU7XG4gICAgY29uc3QgbCA9IGgudHlwZSA9PT0gXCJtaW51c1NpZ25cIiB8fCBoLnR5cGUgPT09IFwicGx1c1NpZ25cIiA/IFwic2lnblwiIDogaC50eXBlO1xuICAgIGwgPT09IFwiaW50ZWdlclwiID8gKGcgPSAhMCwgci5wdXNoKC4uLmgudmFsdWUuc3BsaXQoXCJcIikubWFwKChDKSA9PiAoeyB0eXBlOiBsLCB2YWx1ZTogcGFyc2VJbnQoQykgfSkpKSkgOiBsID09PSBcImdyb3VwXCIgPyByLnB1c2goeyB0eXBlOiBsLCB2YWx1ZTogaC52YWx1ZSB9KSA6IGwgPT09IFwiZGVjaW1hbFwiID8gKHkgPSAhMCwgby5wdXNoKHsgdHlwZTogbCwgdmFsdWU6IGgudmFsdWUsIGtleTogcChsKSB9KSkgOiBsID09PSBcImZyYWN0aW9uXCIgPyBvLnB1c2goLi4uaC52YWx1ZS5zcGxpdChcIlwiKS5tYXAoKEMpID0+ICh7XG4gICAgICB0eXBlOiBsLFxuICAgICAgdmFsdWU6IHBhcnNlSW50KEMpLFxuICAgICAga2V5OiBwKGwpLFxuICAgICAgcG9zOiAtMSAtIGRbbF1cbiAgICB9KSkpIDogKGcgfHwgeSA/IGMgOiBhKS5wdXNoKHtcbiAgICAgIHR5cGU6IGwsXG4gICAgICB2YWx1ZTogaC52YWx1ZSxcbiAgICAgIGtleTogcChsKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IFQgPSBbXTtcbiAgZm9yIChsZXQgaCA9IHIubGVuZ3RoIC0gMTsgaCA+PSAwOyBoLS0pIHtcbiAgICBjb25zdCBsID0gcltoXTtcbiAgICBULnVuc2hpZnQobC50eXBlID09PSBcImludGVnZXJcIiA/IHtcbiAgICAgIC4uLmwsXG4gICAgICBrZXk6IHAobC50eXBlKSxcbiAgICAgIHBvczogZFtsLnR5cGVdXG4gICAgfSA6IHtcbiAgICAgIC4uLmwsXG4gICAgICBrZXk6IHAobC50eXBlKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcHJlOiBhLFxuICAgIGludGVnZXI6IFQsXG4gICAgZnJhY3Rpb246IG8sXG4gICAgcG9zdDogYyxcbiAgICB2YWx1ZUFzU3RyaW5nOiB4LFxuICAgIHZhbHVlOiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiID8gcGFyc2VGbG9hdChuKSA6IG5cbiAgfTtcbn1cbmNvbnN0IEkgPSBTdHJpbmcucmF3LCBWID0gU3RyaW5nLnJhdywgTyA9IF8gJiYgKCgpID0+IHtcbiAgdHJ5IHtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLmFuaW1hdGUoeyBvcGFjaXR5OiAwIH0sIHsgZWFzaW5nOiBcImxpbmVhcigwLCAxKVwiIH0pO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufSkoKSwgeiA9IF8gJiYgdHlwZW9mIENTUyA8IFwidVwiICYmIENTUy5zdXBwb3J0cyAmJiBDU1Muc3VwcG9ydHMoXCJsaW5lLWhlaWdodFwiLCBcIm1vZCgxLDEpXCIpLCBBID0gXyAmJiB0eXBlb2YgbWF0Y2hNZWRpYSA8IFwidVwiID8gbWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpIDogbnVsbCwgJCA9IFwiLS1fbnVtYmVyLWZsb3ctZC1vcGFjaXR5XCIsIFUgPSBcIi0tX251bWJlci1mbG93LWQtd2lkdGhcIiwgUyA9IFwiLS1fbnVtYmVyLWZsb3ctZHhcIiwgaiA9IFwiLS1fbnVtYmVyLWZsb3ctZFwiLCBZID0gKCgpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gQ1NTLnJlZ2lzdGVyUHJvcGVydHkoe1xuICAgICAgbmFtZTogJCxcbiAgICAgIHN5bnRheDogXCI8bnVtYmVyPlwiLFxuICAgICAgaW5oZXJpdHM6ICExLFxuICAgICAgaW5pdGlhbFZhbHVlOiBcIjBcIlxuICAgIH0pLCBDU1MucmVnaXN0ZXJQcm9wZXJ0eSh7XG4gICAgICBuYW1lOiBTLFxuICAgICAgc3ludGF4OiBcIjxsZW5ndGg+XCIsXG4gICAgICBpbmhlcml0czogITAsXG4gICAgICBpbml0aWFsVmFsdWU6IFwiMHB4XCJcbiAgICB9KSwgQ1NTLnJlZ2lzdGVyUHJvcGVydHkoe1xuICAgICAgbmFtZTogVSxcbiAgICAgIHN5bnRheDogXCI8bnVtYmVyPlwiLFxuICAgICAgaW5oZXJpdHM6ICExLFxuICAgICAgaW5pdGlhbFZhbHVlOiBcIjBcIlxuICAgIH0pLCBDU1MucmVnaXN0ZXJQcm9wZXJ0eSh7XG4gICAgICBuYW1lOiBqLFxuICAgICAgc3ludGF4OiBcIjxudW1iZXI+XCIsXG4gICAgICBpbmhlcml0czogITAsXG4gICAgICBpbml0aWFsVmFsdWU6IFwiMFwiXG4gICAgfSksICEwO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn0pKCksIFAgPSBcInZhcigtLW51bWJlci1mbG93LWNoYXItaGVpZ2h0LCAxZW0pXCIsIGYgPSBcInZhcigtLW51bWJlci1mbG93LW1hc2staGVpZ2h0LCAwLjI1ZW0pXCIsIGsgPSBgY2FsYygke2Z9IC8gMilgLCBFID0gXCJ2YXIoLS1udW1iZXItZmxvdy1tYXNrLXdpZHRoLCAwLjVlbSlcIiwgbSA9IGBjYWxjKCR7RX0gLyB2YXIoLS1zY2FsZS14KSlgLCB3ID0gXCIjMDAwIDAsIHRyYW5zcGFyZW50IDcxJVwiLCBNID0gVmA6aG9zdHtkaXNwbGF5OmlubGluZS1ibG9jaztkaXJlY3Rpb246bHRyO3doaXRlLXNwYWNlOm5vd3JhcDtpc29sYXRpb246aXNvbGF0ZTtsaW5lLWhlaWdodDoke1B9ICFpbXBvcnRhbnR9Lm51bWJlciwubnVtYmVyX19pbm5lcntkaXNwbGF5OmlubGluZS1ibG9jazt0cmFuc2Zvcm0tb3JpZ2luOmxlZnQgdG9wfTpob3N0KFtkYXRhLXdpbGwtY2hhbmdlXSkgOmlzKC5udW1iZXIsLm51bWJlcl9faW5uZXIsLnNlY3Rpb24sLmRpZ2l0LC5kaWdpdF9fbnVtLC5zeW1ib2wpe3dpbGwtY2hhbmdlOnRyYW5zZm9ybX0ubnVtYmVyey0tc2NhbGUteDpjYWxjKDEgKyB2YXIoJHtVfSkgLyB2YXIoLS13aWR0aCkpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKHZhcigke1N9KSkgc2NhbGVYKHZhcigtLXNjYWxlLXgpKTttYXJnaW46MCBjYWxjKC0xICogJHtFfSk7cG9zaXRpb246cmVsYXRpdmU7LXdlYmtpdC1tYXNrLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byByaWdodCx0cmFuc3BhcmVudCAwLCMwMDAgJHttfSwjMDAwIGNhbGMoMTAwJSAtICR7bX0pLHRyYW5zcGFyZW50ICksbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSx0cmFuc3BhcmVudCAwLCMwMDAgJHtmfSwjMDAwIGNhbGMoMTAwJSAtICR7Zn0pLHRyYW5zcGFyZW50IDEwMCUgKSxyYWRpYWwtZ3JhZGllbnQoYXQgYm90dG9tIHJpZ2h0LCR7d30pLHJhZGlhbC1ncmFkaWVudChhdCBib3R0b20gbGVmdCwke3d9KSxyYWRpYWwtZ3JhZGllbnQoYXQgdG9wIGxlZnQsJHt3fSkscmFkaWFsLWdyYWRpZW50KGF0IHRvcCByaWdodCwke3d9KTstd2Via2l0LW1hc2stc2l6ZToxMDAlIGNhbGMoMTAwJSAtICR7Zn0gKiAyKSxjYWxjKDEwMCUgLSAke219ICogMikgMTAwJSwke219ICR7Zn0sJHttfSAke2Z9LCR7bX0gJHtmfSwke219ICR7Zn07LXdlYmtpdC1tYXNrLXBvc2l0aW9uOmNlbnRlcixjZW50ZXIsdG9wIGxlZnQsdG9wIHJpZ2h0LGJvdHRvbSByaWdodCxib3R0b20gbGVmdDstd2Via2l0LW1hc2stcmVwZWF0Om5vLXJlcGVhdH0ubnVtYmVyX19pbm5lcntwYWRkaW5nOiR7a30gJHtFfTt0cmFuc2Zvcm06c2NhbGVYKGNhbGMoMSAvIHZhcigtLXNjYWxlLXgpKSkgdHJhbnNsYXRlWChjYWxjKC0xICogdmFyKCR7U30pKSl9Omhvc3QgPiA6bm90KC5udW1iZXIpe3otaW5kZXg6NX0uc2VjdGlvbiwuc3ltYm9se2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO2lzb2xhdGlvbjppc29sYXRlfS5zZWN0aW9uOjphZnRlcntjb250ZW50OidcXDIwMGInO2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5zZWN0aW9uLS1qdXN0aWZ5LWxlZnR7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgbGVmdH0uc2VjdGlvbi0tanVzdGlmeS1yaWdodHt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciByaWdodH0uc2VjdGlvbiA+IFtpbmVydF0sLnN5bWJvbCA+IFtpbmVydF17bWFyZ2luOjAgIWltcG9ydGFudDtwb3NpdGlvbjphYnNvbHV0ZSAhaW1wb3J0YW50O3otaW5kZXg6LTF9LmRpZ2l0e2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlOy0tYzp2YXIoLS1jdXJyZW50KSArIHZhcigke2p9KX0uZGlnaXRfX251bSwubnVtYmVyIC5zZWN0aW9uOjphZnRlcntwYWRkaW5nOiR7a30gMH0uZGlnaXRfX251bXtkaXNwbGF5OmlubGluZS1ibG9jazstLW9mZnNldC1yYXc6bW9kKHZhcigtLWxlbmd0aCkgKyB2YXIoLS1uKSAtIG1vZCh2YXIoLS1jKSx2YXIoLS1sZW5ndGgpKSx2YXIoLS1sZW5ndGgpKTstLW9mZnNldDpjYWxjKCB2YXIoLS1vZmZzZXQtcmF3KSAtIHZhcigtLWxlbmd0aCkgKiByb3VuZChkb3duLHZhcigtLW9mZnNldC1yYXcpIC8gKHZhcigtLWxlbmd0aCkgLyAyKSwxKSApOy0teTpjbGFtcCgtMTAwJSx2YXIoLS1vZmZzZXQpICogMTAwJSwxMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSh2YXIoLS15KSl9LmRpZ2l0X19udW1baW5lcnRde3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkodmFyKC0teSkpfS5kaWdpdDpub3QoLmlzLXNwaW5uaW5nKSAuZGlnaXRfX251bVtpbmVydF17ZGlzcGxheTpub25lfS5zeW1ib2xfX3ZhbHVle2Rpc3BsYXk6aW5saW5lLWJsb2NrO21peC1ibGVuZC1tb2RlOnBsdXMtbGlnaHRlcjt3aGl0ZS1zcGFjZTpwcmV9LnNlY3Rpb24tLWp1c3RpZnktbGVmdCAuc3ltYm9sID4gW2luZXJ0XXtsZWZ0OjB9LnNlY3Rpb24tLWp1c3RpZnktcmlnaHQgLnN5bWJvbCA+IFtpbmVydF17cmlnaHQ6MH0uYW5pbWF0ZS1wcmVzZW5jZXtvcGFjaXR5OmNhbGMoMSArIHZhcigkeyR9KSl9YCwgRyA9IF8gPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcbn0sIEsgPSBWYDpob3N0e2Rpc3BsYXk6aW5saW5lLWJsb2NrO2RpcmVjdGlvbjpsdHI7d2hpdGUtc3BhY2U6bm93cmFwO2xpbmUtaGVpZ2h0OiR7UH0gIWltcG9ydGFudH1zcGFue2Rpc3BsYXk6aW5saW5lLWJsb2NrfTpob3N0KFtkYXRhLXdpbGwtY2hhbmdlXSkgc3Bhbnt3aWxsLWNoYW5nZTp0cmFuc2Zvcm19Lm51bWJlciwuZGlnaXR7cGFkZGluZzoke2t9IDB9LnN5bWJvbHt3aGl0ZS1zcGFjZTpwcmV9YCwgWiA9IChuKSA9PiBgPHNwYW4gY2xhc3M9XCIke24udHlwZSA9PT0gXCJpbnRlZ2VyXCIgfHwgbi50eXBlID09PSBcImZyYWN0aW9uXCIgPyBcImRpZ2l0XCIgOiBcInN5bWJvbFwifVwiIHBhcnQ9XCIke24udHlwZSA9PT0gXCJpbnRlZ2VyXCIgfHwgbi50eXBlID09PSBcImZyYWN0aW9uXCIgPyBgZGlnaXQgJHtuLnR5cGV9LWRpZ2l0YCA6IGBzeW1ib2wgJHtuLnR5cGV9YH1cIj4ke24udmFsdWV9PC9zcGFuPmAsIHYgPSAobiwgdCkgPT4gYDxzcGFuIHBhcnQ9XCIke3R9XCI+JHtuLnJlZHVjZSgoZSwgaSkgPT4gZSArIFooaSksIFwiXCIpfTwvc3Bhbj5gLCBhdCA9IChuKSA9PiAoXG4gIC8vIHNoYWRvd3Jvb3Q9XCJvcGVuXCIgbm9uLXN0YW5kYXJkIGF0dHJpYnV0ZSBmb3Igb2xkIENocm9tZTpcbiAgSWA8dGVtcGxhdGUgc2hhZG93cm9vdD1cIm9wZW5cIiBzaGFkb3dyb290bW9kZT1cIm9wZW5cIlxuXHRcdFx0PjxzdHlsZT5cblx0XHRcdFx0JHtLfTwvc3R5bGVcblx0XHRcdD48c3BhbiByb2xlPVwiaW1nXCIgYXJpYS1sYWJlbD1cIiR7bi52YWx1ZUFzU3RyaW5nfVwiXG5cdFx0XHRcdD4ke3Yobi5wcmUsIFwibGVmdFwiKX08c3BhbiBwYXJ0PVwibnVtYmVyXCIgY2xhc3M9XCJudW1iZXJcIlxuXHRcdFx0XHRcdD4ke3Yobi5pbnRlZ2VyLCBcImludGVnZXJcIil9JHt2KG4uZnJhY3Rpb24sIFwiZnJhY3Rpb25cIil9PC9zcGFuXG5cdFx0XHRcdD4ke3Yobi5wb3N0LCBcInJpZ2h0XCIpfTwvc3BhblxuXHRcdFx0PjwvdGVtcGxhdGVcblx0XHQ+PHNwYW5cblx0XHRcdHN0eWxlPVwiZm9udC1rZXJuaW5nOiBub25lOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGxpbmUtaGVpZ2h0OiAke1B9ICFpbXBvcnRhbnQ7IHBhZGRpbmc6ICR7Zn0gMDtcIlxuXHRcdFx0PiR7bi52YWx1ZUFzU3RyaW5nfTwvc3BhblxuXHRcdD5gXG4pLCBxID0geiAmJiBPICYmIFk7XG5sZXQgYjtcbmNsYXNzIEogZXh0ZW5kcyBHIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jcmVhdGVkID0gITEsIHRoaXMuYmF0Y2hlZCA9ICExO1xuICAgIGNvbnN0IHsgYW5pbWF0ZWQ6IHQsIC4uLmUgfSA9IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdFByb3BzO1xuICAgIHRoaXMuX2FuaW1hdGVkID0gdGhpcy5jb21wdXRlZEFuaW1hdGVkID0gdCwgT2JqZWN0LmFzc2lnbih0aGlzLCBlKTtcbiAgfVxuICBnZXQgYW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdGVkO1xuICB9XG4gIHNldCBhbmltYXRlZCh0KSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5hbmltYXRlZCAhPT0gdCAmJiAodGhpcy5fYW5pbWF0ZWQgPSB0LCAoZSA9IHRoaXMuc2hhZG93Um9vdCkgPT0gbnVsbCB8fCBlLmdldEFuaW1hdGlvbnMoKS5mb3JFYWNoKChpKSA9PiBpLmZpbmlzaCgpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0IGRhdGEodCkge1xuICAgIHZhciBvO1xuICAgIGlmICh0ID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBwcmU6IGUsIGludGVnZXI6IGksIGZyYWN0aW9uOiBzLCBwb3N0OiBhLCB2YWx1ZTogciB9ID0gdDtcbiAgICBpZiAodGhpcy5jcmVhdGVkKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5fZGF0YTtcbiAgICAgIHRoaXMuX2RhdGEgPSB0LCB0aGlzLmNvbXB1dGVkVHJlbmQgPSB0eXBlb2YgdGhpcy50cmVuZCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLnRyZW5kKGMudmFsdWUsIHIpIDogdGhpcy50cmVuZCwgdGhpcy5jb21wdXRlZEFuaW1hdGVkID0gcSAmJiB0aGlzLl9hbmltYXRlZCAmJiAoIXRoaXMucmVzcGVjdE1vdGlvblByZWZlcmVuY2UgfHwgIShBICE9IG51bGwgJiYgQS5tYXRjaGVzKSkgJiYgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhcnZpYW4vbnVtYmVyLWZsb3cvaXNzdWVzLzlcbiAgICAgIEgodGhpcyksIChvID0gdGhpcy5wbHVnaW5zKSA9PSBudWxsIHx8IG8uZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICB2YXIgcDtcbiAgICAgICAgcmV0dXJuIChwID0gZC5vblVwZGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHAuY2FsbChkLCB0LCBjLCB0aGlzKTtcbiAgICAgIH0pLCB0aGlzLmJhdGNoZWQgfHwgdGhpcy53aWxsVXBkYXRlKCksIHRoaXMuX3ByZS51cGRhdGUoZSksIHRoaXMuX251bS51cGRhdGUoeyBpbnRlZ2VyOiBpLCBmcmFjdGlvbjogcyB9KSwgdGhpcy5fcG9zdC51cGRhdGUoYSksIHRoaXMuYmF0Y2hlZCB8fCB0aGlzLmRpZFVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gdCwgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFscyA/PyAodGhpcy5faW50ZXJuYWxzID0gdGhpcy5hdHRhY2hJbnRlcm5hbHMoKSksIHRoaXMuX2ludGVybmFscy5yb2xlID0gXCJpbWdcIjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBDU1NTdHlsZVNoZWV0IDwgXCJ1XCIgJiYgdGhpcy5zaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0cylcbiAgICAgICAgYiB8fCAoYiA9IG5ldyBDU1NTdHlsZVNoZWV0KCksIGIucmVwbGFjZVN5bmMoTSkpLCB0aGlzLnNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID0gW2JdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIGMudGV4dENvbnRlbnQgPSBNLCB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wcmUgPSBuZXcgTih0aGlzLCBlLCB7XG4gICAgICAgIGp1c3RpZnk6IFwicmlnaHRcIixcbiAgICAgICAgcGFydDogXCJsZWZ0XCJcbiAgICAgIH0pLCB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGhpcy5fcHJlLmVsKSwgdGhpcy5fbnVtID0gbmV3IFEodGhpcywgaSwgcyksIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLl9udW0uZWwpLCB0aGlzLl9wb3N0ID0gbmV3IE4odGhpcywgYSwge1xuICAgICAgICBqdXN0aWZ5OiBcImxlZnRcIixcbiAgICAgICAgcGFydDogXCJyaWdodFwiXG4gICAgICB9KSwgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHRoaXMuX3Bvc3QuZWwpLCB0aGlzLmNyZWF0ZWQgPSAhMDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2ludGVybmFscy5hcmlhTGFiZWwgPSB0LnZhbHVlQXNTdHJpbmc7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHdpbGxVcGRhdGUoKSB7XG4gICAgdGhpcy5fcHJlLndpbGxVcGRhdGUoKSwgdGhpcy5fbnVtLndpbGxVcGRhdGUoKSwgdGhpcy5fcG9zdC53aWxsVXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGlkVXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5jb21wdXRlZEFuaW1hdGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2Fib3J0QW5pbWF0aW9uc0ZpbmlzaCA/IHRoaXMuX2Fib3J0QW5pbWF0aW9uc0ZpbmlzaC5hYm9ydCgpIDogdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImFuaW1hdGlvbnNzdGFydFwiKSksIHRoaXMuX3ByZS5kaWRVcGRhdGUoKSwgdGhpcy5fbnVtLmRpZFVwZGF0ZSgpLCB0aGlzLl9wb3N0LmRpZFVwZGF0ZSgpO1xuICAgIGNvbnN0IHQgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgUHJvbWlzZS5hbGwodGhpcy5zaGFkb3dSb290LmdldEFuaW1hdGlvbnMoKS5tYXAoKGUpID0+IGUuZmluaXNoZWQpKS50aGVuKCgpID0+IHtcbiAgICAgIHQuc2lnbmFsLmFib3J0ZWQgfHwgKHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJhbmltYXRpb25zZmluaXNoXCIpKSwgdGhpcy5fYWJvcnRBbmltYXRpb25zRmluaXNoID0gdm9pZCAwKTtcbiAgICB9KSwgdGhpcy5fYWJvcnRBbmltYXRpb25zRmluaXNoID0gdDtcbiAgfVxufVxuSi5kZWZhdWx0UHJvcHMgPSB7XG4gIHRyYW5zZm9ybVRpbWluZzoge1xuICAgIGR1cmF0aW9uOiA5MDAsXG4gICAgLy8gTWFrZSBzdXJlIHRvIGtlZXAgdGhpcyBtaW5pZmllZDpcbiAgICBlYXNpbmc6IFwibGluZWFyKDAsLjAwNSwuMDE5LC4wMzksLjA2NiwuMDk2LC4xMjksLjE2NSwuMjAyLC4yNCwuMjc4LC4zMTYsLjM1NCwuMzksLjQyNiwuNDYxLC40OTQsLjUyNiwuNTU3LC41ODYsLjYxNCwuNjQsLjY2NSwuNjg5LC43MTEsLjczMSwuNzUxLC43NjksLjc4NiwuODAyLC44MTcsLjgzMSwuODQ0LC44NTYsLjg2NywuODc3LC44ODcsLjg5NiwuOTA0LC45MTIsLjkxOSwuOTI1LC45MzEsLjkzNywuOTQyLC45NDcsLjk1MSwuOTU1LC45NTksLjk2MiwuOTY1LC45NjgsLjk3MSwuOTczLC45NzYsLjk3OCwuOTgsLjk4MSwuOTgzLC45ODQsLjk4NiwuOTg3LC45ODgsLjk4OSwuOTksLjk5MSwuOTkyLC45OTIsLjk5MywuOTk0LC45OTQsLjk5NSwuOTk1LC45OTYsLjk5NiwuOTk2MywuOTk2NywuOTk2OSwuOTk3MiwuOTk3NSwuOTk3NywuOTk3OSwuOTk4MSwuOTk4MiwuOTk4NCwuOTk4NSwuOTk4NywuOTk4OCwuOTk4OSwxKVwiXG4gIH0sXG4gIHNwaW5UaW1pbmc6IHZvaWQgMCxcbiAgb3BhY2l0eVRpbWluZzogeyBkdXJhdGlvbjogNDUwLCBlYXNpbmc6IFwiZWFzZS1vdXRcIiB9LFxuICBhbmltYXRlZDogITAsXG4gIHRyZW5kOiAobiwgdCkgPT4gTWF0aC5zaWduKHQgLSBuKSxcbiAgcmVzcGVjdE1vdGlvblByZWZlcmVuY2U6ICEwLFxuICBwbHVnaW5zOiB2b2lkIDAsXG4gIGRpZ2l0czogdm9pZCAwXG59O1xuY2xhc3MgUSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGksIHsgY2xhc3NOYW1lOiBzLCAuLi5hIH0gPSB7fSkge1xuICAgIHRoaXMuZmxvdyA9IHQsIHRoaXMuX2ludGVnZXIgPSBuZXcgTCh0LCBlLCB7XG4gICAgICBqdXN0aWZ5OiBcInJpZ2h0XCIsXG4gICAgICBwYXJ0OiBcImludGVnZXJcIlxuICAgIH0pLCB0aGlzLl9mcmFjdGlvbiA9IG5ldyBMKHQsIGksIHtcbiAgICAgIGp1c3RpZnk6IFwibGVmdFwiLFxuICAgICAgcGFydDogXCJmcmFjdGlvblwiXG4gICAgfSksIHRoaXMuX2lubmVyID0gdShcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIm51bWJlcl9faW5uZXJcIlxuICAgIH0sIFt0aGlzLl9pbnRlZ2VyLmVsLCB0aGlzLl9mcmFjdGlvbi5lbF0pLCB0aGlzLmVsID0gdShcInNwYW5cIiwge1xuICAgICAgLi4uYSxcbiAgICAgIHBhcnQ6IFwibnVtYmVyXCIsXG4gICAgICBjbGFzc05hbWU6IGBudW1iZXIgJHtzID8/IFwiXCJ9YFxuICAgIH0sIFt0aGlzLl9pbm5lcl0pO1xuICB9XG4gIHdpbGxVcGRhdGUoKSB7XG4gICAgdGhpcy5fcHJldldpZHRoID0gdGhpcy5lbC5vZmZzZXRXaWR0aCwgdGhpcy5fcHJldkxlZnQgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQsIHRoaXMuX2ludGVnZXIud2lsbFVwZGF0ZSgpLCB0aGlzLl9mcmFjdGlvbi53aWxsVXBkYXRlKCk7XG4gIH1cbiAgdXBkYXRlKHsgaW50ZWdlcjogdCwgZnJhY3Rpb246IGUgfSkge1xuICAgIHRoaXMuX2ludGVnZXIudXBkYXRlKHQpLCB0aGlzLl9mcmFjdGlvbi51cGRhdGUoZSk7XG4gIH1cbiAgZGlkVXBkYXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX2ludGVnZXIuZGlkVXBkYXRlKCksIHRoaXMuX2ZyYWN0aW9uLmRpZFVwZGF0ZSgpO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9wcmV2TGVmdCAtIHQubGVmdCwgaSA9IHRoaXMuZWwub2Zmc2V0V2lkdGgsIHMgPSB0aGlzLl9wcmV2V2lkdGggLSBpO1xuICAgIHRoaXMuZWwuc3R5bGUuc2V0UHJvcGVydHkoXCItLXdpZHRoXCIsIFN0cmluZyhpKSksIHRoaXMuZWwuYW5pbWF0ZSh7XG4gICAgICBbU106IFtgJHtlfXB4YCwgXCIwcHhcIl0sXG4gICAgICBbVV06IFtzLCAwXVxuICAgIH0sIHtcbiAgICAgIC4uLnRoaXMuZmxvdy50cmFuc2Zvcm1UaW1pbmcsXG4gICAgICBjb21wb3NpdGU6IFwiYWNjdW11bGF0ZVwiXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFcge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCB7IGp1c3RpZnk6IGksIGNsYXNzTmFtZTogcywgLi4uYSB9LCByKSB7XG4gICAgdGhpcy5mbG93ID0gdCwgdGhpcy5jaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMub25DaGFyUmVtb3ZlID0gKGMpID0+ICgpID0+IHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZGVsZXRlKGMpO1xuICAgIH0sIHRoaXMuanVzdGlmeSA9IGk7XG4gICAgY29uc3QgbyA9IGUubWFwKChjKSA9PiB0aGlzLmFkZENoYXIoYykuZWwpO1xuICAgIHRoaXMuZWwgPSB1KFwic3BhblwiLCB7XG4gICAgICAuLi5hLFxuICAgICAgY2xhc3NOYW1lOiBgc2VjdGlvbiBzZWN0aW9uLS1qdXN0aWZ5LSR7aX0gJHtzID8/IFwiXCJ9YFxuICAgIH0sIHIgPyByKG8pIDogbyk7XG4gIH1cbiAgYWRkQ2hhcih0LCB7IHN0YXJ0RGlnaXRzQXRaZXJvOiBlID0gITEsIC4uLmkgfSA9IHt9KSB7XG4gICAgY29uc3QgcyA9IHQudHlwZSA9PT0gXCJpbnRlZ2VyXCIgfHwgdC50eXBlID09PSBcImZyYWN0aW9uXCIgPyBuZXcgRCh0aGlzLCB0LnR5cGUsIGUgPyAwIDogdC52YWx1ZSwgdC5wb3MsIHtcbiAgICAgIC4uLmksXG4gICAgICBvblJlbW92ZTogdGhpcy5vbkNoYXJSZW1vdmUodC5rZXkpXG4gICAgfSkgOiBuZXcgdHQodGhpcywgdC50eXBlLCB0LnZhbHVlLCB7XG4gICAgICAuLi5pLFxuICAgICAgb25SZW1vdmU6IHRoaXMub25DaGFyUmVtb3ZlKHQua2V5KVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnNldCh0LmtleSwgcyksIHM7XG4gIH1cbiAgdW5wb3AodCkge1xuICAgIHQuZWwucmVtb3ZlQXR0cmlidXRlKFwiaW5lcnRcIiksIHQuZWwuc3R5bGUudG9wID0gXCJcIiwgdC5lbC5zdHlsZVt0aGlzLmp1c3RpZnldID0gXCJcIjtcbiAgfVxuICBwb3AodCkge1xuICAgIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5lbC5zdHlsZS50b3AgPSBgJHtlLmVsLm9mZnNldFRvcH1weGAsIGUuZWwuc3R5bGVbdGhpcy5qdXN0aWZ5XSA9IGAke0YoZS5lbCwgdGhpcy5qdXN0aWZ5KX1weGA7XG4gICAgfSksIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5lbC5zZXRBdHRyaWJ1dGUoXCJpbmVydFwiLCBcIlwiKSwgZS5wcmVzZW50ID0gITE7XG4gICAgfSk7XG4gIH1cbiAgYWRkTmV3QW5kVXBkYXRlRXhpc3RpbmcodCkge1xuICAgIGNvbnN0IGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBpID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgcyA9IHRoaXMuanVzdGlmeSA9PT0gXCJsZWZ0XCIsIGEgPSBzID8gXCJwcmVwZW5kXCIgOiBcImFwcGVuZFwiO1xuICAgIGlmIChYKHQsIChyKSA9PiB7XG4gICAgICBsZXQgbztcbiAgICAgIHRoaXMuY2hpbGRyZW4uaGFzKHIua2V5KSA/IChvID0gdGhpcy5jaGlsZHJlbi5nZXQoci5rZXkpLCBpLnNldChyLCBvKSwgdGhpcy51bnBvcChvKSwgby5wcmVzZW50ID0gITApIDogKG8gPSB0aGlzLmFkZENoYXIociwgeyBzdGFydERpZ2l0c0F0WmVybzogITAsIGFuaW1hdGVJbjogITAgfSksIGUuc2V0KHIsIG8pKSwgdGhpcy5lbFthXShvLmVsKTtcbiAgICB9LCB7IHJldmVyc2U6IHMgfSksIHRoaXMuZmxvdy5jb21wdXRlZEFuaW1hdGVkKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGUuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBvLndpbGxVcGRhdGUocik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZS5mb3JFYWNoKChyLCBvKSA9PiB7XG4gICAgICByLnVwZGF0ZShvLnZhbHVlKTtcbiAgICB9KSwgaS5mb3JFYWNoKChyLCBvKSA9PiB7XG4gICAgICByLnVwZGF0ZShvLnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICB3aWxsVXBkYXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX3ByZXZPZmZzZXQgPSB0W3RoaXMuanVzdGlmeV0sIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoZSkgPT4gZS53aWxsVXBkYXRlKHQpKTtcbiAgfVxuICBkaWRVcGRhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChzKSA9PiBzLmRpZFVwZGF0ZSh0KSk7XG4gICAgY29uc3QgZSA9IHRbdGhpcy5qdXN0aWZ5XSwgaSA9IHRoaXMuX3ByZXZPZmZzZXQgLSBlO1xuICAgIGkgJiYgdGhpcy5jaGlsZHJlbi5zaXplICYmIHRoaXMuZWwuYW5pbWF0ZSh7XG4gICAgICB0cmFuc2Zvcm06IFtgdHJhbnNsYXRlWCgke2l9cHgpYCwgXCJub25lXCJdXG4gICAgfSwge1xuICAgICAgLi4udGhpcy5mbG93LnRyYW5zZm9ybVRpbWluZyxcbiAgICAgIGNvbXBvc2l0ZTogXCJhY2N1bXVsYXRlXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgTCBleHRlbmRzIFcge1xuICB1cGRhdGUodCkge1xuICAgIGNvbnN0IGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoaSwgcykgPT4ge1xuICAgICAgdC5maW5kKChhKSA9PiBhLmtleSA9PT0gcykgfHwgZS5zZXQocywgaSksIHRoaXMudW5wb3AoaSk7XG4gICAgfSksIHRoaXMuYWRkTmV3QW5kVXBkYXRlRXhpc3RpbmcodCksIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgaSBpbnN0YW5jZW9mIEQgJiYgaS51cGRhdGUoMCk7XG4gICAgfSksIHRoaXMucG9wKGUpO1xuICB9XG59XG5jbGFzcyBOIGV4dGVuZHMgVyB7XG4gIHVwZGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChpLCBzKSA9PiB7XG4gICAgICB0LmZpbmQoKGEpID0+IGEua2V5ID09PSBzKSB8fCBlLnNldChzLCBpKTtcbiAgICB9KSwgdGhpcy5wb3AoZSksIHRoaXMuYWRkTmV3QW5kVXBkYXRlRXhpc3RpbmcodCk7XG4gIH1cbn1cbmNsYXNzIFIge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCB7IG9uUmVtb3ZlOiBpLCBhbmltYXRlSW46IHMgPSAhMSB9ID0ge30pIHtcbiAgICB0aGlzLmZsb3cgPSB0LCB0aGlzLmVsID0gZSwgdGhpcy5fcHJlc2VudCA9ICEwLCB0aGlzLl9yZW1vdmUgPSAoKSA9PiB7XG4gICAgICB2YXIgYTtcbiAgICAgIHRoaXMuZWwucmVtb3ZlKCksIChhID0gdGhpcy5fb25SZW1vdmUpID09IG51bGwgfHwgYS5jYWxsKHRoaXMpO1xuICAgIH0sIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImFuaW1hdGUtcHJlc2VuY2VcIiksIHRoaXMuZmxvdy5jb21wdXRlZEFuaW1hdGVkICYmIHMgJiYgdGhpcy5lbC5hbmltYXRlKHtcbiAgICAgIFskXTogWy0wLjk5OTksIDBdXG4gICAgfSwge1xuICAgICAgLi4udGhpcy5mbG93Lm9wYWNpdHlUaW1pbmcsXG4gICAgICBjb21wb3NpdGU6IFwiYWNjdW11bGF0ZVwiXG4gICAgfSksIHRoaXMuX29uUmVtb3ZlID0gaTtcbiAgfVxuICBnZXQgcHJlc2VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlc2VudDtcbiAgfVxuICBzZXQgcHJlc2VudCh0KSB7XG4gICAgaWYgKHRoaXMuX3ByZXNlbnQgIT09IHQpIHtcbiAgICAgIGlmICh0aGlzLl9wcmVzZW50ID0gdCwgdCA/IHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFwiaW5lcnRcIikgOiB0aGlzLmVsLnNldEF0dHJpYnV0ZShcImluZXJ0XCIsIFwiXCIpLCAhdGhpcy5mbG93LmNvbXB1dGVkQW5pbWF0ZWQpIHtcbiAgICAgICAgdCB8fCB0aGlzLl9yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tX251bWJlci1mbG93LWQtb3BhY2l0eVwiLCB0ID8gXCIwXCIgOiBcIi0uOTk5XCIpLCB0aGlzLmVsLmFuaW1hdGUoe1xuICAgICAgICBbJF06IHQgPyBbLTAuOTk5OSwgMF0gOiBbMC45OTksIDBdXG4gICAgICB9LCB7XG4gICAgICAgIC4uLnRoaXMuZmxvdy5vcGFjaXR5VGltaW5nLFxuICAgICAgICBjb21wb3NpdGU6IFwiYWNjdW11bGF0ZVwiXG4gICAgICB9KSwgdCA/IHRoaXMuZmxvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uc2ZpbmlzaFwiLCB0aGlzLl9yZW1vdmUpIDogdGhpcy5mbG93LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25zZmluaXNoXCIsIHRoaXMuX3JlbW92ZSwge1xuICAgICAgICBvbmNlOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBCIGV4dGVuZHMgUiB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGksIHMpIHtcbiAgICBzdXBlcih0LmZsb3csIGksIHMpLCB0aGlzLnNlY3Rpb24gPSB0LCB0aGlzLnZhbHVlID0gZSwgdGhpcy5lbCA9IGk7XG4gIH1cbn1cbmNsYXNzIEQgZXh0ZW5kcyBCIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSwgcywgYSkge1xuICAgIHZhciBkLCBwO1xuICAgIGNvbnN0IHIgPSAoKChwID0gKGQgPSB0LmZsb3cuZGlnaXRzKSA9PSBudWxsID8gdm9pZCAwIDogZFtzXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHAubWF4KSA/PyA5KSArIDEsIG8gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiByIH0pLm1hcCgoeCwgZykgPT4ge1xuICAgICAgY29uc3QgeSA9IHUoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImRpZ2l0X19udW1cIiB9LCBbXG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhnKSlcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIGcgIT09IGkgJiYgeS5zZXRBdHRyaWJ1dGUoXCJpbmVydFwiLCBcIlwiKSwgeS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tblwiLCBTdHJpbmcoZykpLCB5O1xuICAgIH0pLCBjID0gdShcInNwYW5cIiwge1xuICAgICAgcGFydDogYGRpZ2l0ICR7ZX0tZGlnaXRgLFxuICAgICAgY2xhc3NOYW1lOiBcImRpZ2l0XCJcbiAgICB9LCBvKTtcbiAgICBjLnN0eWxlLnNldFByb3BlcnR5KFwiLS1jdXJyZW50XCIsIFN0cmluZyhpKSksIGMuc3R5bGUuc2V0UHJvcGVydHkoXCItLWxlbmd0aFwiLCBTdHJpbmcocikpLCBzdXBlcih0LCBpLCBjLCBhKSwgdGhpcy5wb3MgPSBzLCB0aGlzLl9vbkFuaW1hdGlvbnNGaW5pc2ggPSAoKSA9PiB7XG4gICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1zcGlubmluZ1wiKTtcbiAgICB9LCB0aGlzLl9udW1iZXJzID0gbywgdGhpcy5sZW5ndGggPSByO1xuICB9XG4gIHdpbGxVcGRhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX3ByZXZWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgY29uc3QgaSA9IGVbdGhpcy5zZWN0aW9uLmp1c3RpZnldIC0gdFt0aGlzLnNlY3Rpb24uanVzdGlmeV0sIHMgPSBlLndpZHRoIC8gMjtcbiAgICB0aGlzLl9wcmV2Q2VudGVyID0gdGhpcy5zZWN0aW9uLmp1c3RpZnkgPT09IFwibGVmdFwiID8gaSArIHMgOiBpIC0gcztcbiAgfVxuICB1cGRhdGUodCkge1xuICAgIHRoaXMuZWwuc3R5bGUuc2V0UHJvcGVydHkoXCItLWN1cnJlbnRcIiwgU3RyaW5nKHQpKSwgdGhpcy5fbnVtYmVycy5mb3JFYWNoKChlLCBpKSA9PiBpID09PSB0ID8gZS5yZW1vdmVBdHRyaWJ1dGUoXCJpbmVydFwiKSA6IGUuc2V0QXR0cmlidXRlKFwiaW5lcnRcIiwgXCJcIikpLCB0aGlzLnZhbHVlID0gdDtcbiAgfVxuICBkaWRVcGRhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBpID0gZVt0aGlzLnNlY3Rpb24uanVzdGlmeV0gLSB0W3RoaXMuc2VjdGlvbi5qdXN0aWZ5XSwgcyA9IGUud2lkdGggLyAyLCBhID0gdGhpcy5zZWN0aW9uLmp1c3RpZnkgPT09IFwibGVmdFwiID8gaSArIHMgOiBpIC0gcywgciA9IHRoaXMuX3ByZXZDZW50ZXIgLSBhO1xuICAgIHIgJiYgdGhpcy5lbC5hbmltYXRlKHtcbiAgICAgIHRyYW5zZm9ybTogW2B0cmFuc2xhdGVYKCR7cn1weClgLCBcIm5vbmVcIl1cbiAgICB9LCB7XG4gICAgICAuLi50aGlzLmZsb3cudHJhbnNmb3JtVGltaW5nLFxuICAgICAgY29tcG9zaXRlOiBcImFjY3VtdWxhdGVcIlxuICAgIH0pO1xuICAgIGNvbnN0IG8gPSB0aGlzLmdldERlbHRhKCk7XG4gICAgbyAmJiAodGhpcy5lbC5jbGFzc0xpc3QuYWRkKFwiaXMtc3Bpbm5pbmdcIiksIHRoaXMuZWwuYW5pbWF0ZSh7XG4gICAgICBbal06IFstbywgMF1cbiAgICB9LCB7XG4gICAgICAuLi50aGlzLmZsb3cuc3BpblRpbWluZyA/PyB0aGlzLmZsb3cudHJhbnNmb3JtVGltaW5nLFxuICAgICAgY29tcG9zaXRlOiBcImFjY3VtdWxhdGVcIlxuICAgIH0pLCB0aGlzLmZsb3cuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnNmaW5pc2hcIiwgdGhpcy5fb25BbmltYXRpb25zRmluaXNoLCB7IG9uY2U6ICEwIH0pKTtcbiAgfVxuICBnZXREZWx0YSgpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAodGhpcy5mbG93LnBsdWdpbnMpXG4gICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5mbG93LnBsdWdpbnMpIHtcbiAgICAgICAgY29uc3QgYSA9IChpID0gcy5nZXREZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuY2FsbChzLCB0aGlzLnZhbHVlLCB0aGlzLl9wcmV2VmFsdWUsIHRoaXMpO1xuICAgICAgICBpZiAoYSAhPSBudWxsKVxuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgIGNvbnN0IHQgPSB0aGlzLnZhbHVlIC0gdGhpcy5fcHJldlZhbHVlLCBlID0gdGhpcy5mbG93LmNvbXB1dGVkVHJlbmQgfHwgTWF0aC5zaWduKHQpO1xuICAgIHJldHVybiBlIDwgMCAmJiB0aGlzLnZhbHVlID4gdGhpcy5fcHJldlZhbHVlID8gdGhpcy52YWx1ZSAtIHRoaXMubGVuZ3RoIC0gdGhpcy5fcHJldlZhbHVlIDogZSA+IDAgJiYgdGhpcy52YWx1ZSA8IHRoaXMuX3ByZXZWYWx1ZSA/IHRoaXMubGVuZ3RoIC0gdGhpcy5fcHJldlZhbHVlICsgdGhpcy52YWx1ZSA6IHQ7XG4gIH1cbn1cbmNsYXNzIHR0IGV4dGVuZHMgQiB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGksIHMpIHtcbiAgICBjb25zdCBhID0gdShcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInN5bWJvbF9fdmFsdWVcIixcbiAgICAgIHRleHRDb250ZW50OiBpXG4gICAgfSk7XG4gICAgc3VwZXIodCwgaSwgdShcInNwYW5cIiwge1xuICAgICAgcGFydDogYHN5bWJvbCAke2V9YCxcbiAgICAgIGNsYXNzTmFtZTogXCJzeW1ib2xcIlxuICAgIH0sIFthXSksIHMpLCB0aGlzLnR5cGUgPSBlLCB0aGlzLl9jaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuX29uQ2hpbGRSZW1vdmUgPSAocikgPT4gKCkgPT4ge1xuICAgICAgdGhpcy5fY2hpbGRyZW4uZGVsZXRlKHIpO1xuICAgIH0sIHRoaXMuX2NoaWxkcmVuLnNldChpLCBuZXcgUih0aGlzLmZsb3csIGEsIHtcbiAgICAgIG9uUmVtb3ZlOiB0aGlzLl9vbkNoaWxkUmVtb3ZlKGkpXG4gICAgfSkpO1xuICB9XG4gIHdpbGxVcGRhdGUodCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IFwiZGVjaW1hbFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX3ByZXZPZmZzZXQgPSBlW3RoaXMuc2VjdGlvbi5qdXN0aWZ5XSAtIHRbdGhpcy5zZWN0aW9uLmp1c3RpZnldO1xuICB9XG4gIHVwZGF0ZSh0KSB7XG4gICAgaWYgKHRoaXMudmFsdWUgIT09IHQpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9jaGlsZHJlbi5nZXQodGhpcy52YWx1ZSk7XG4gICAgICBlICYmIChlLnByZXNlbnQgPSAhMSk7XG4gICAgICBjb25zdCBpID0gdGhpcy5fY2hpbGRyZW4uZ2V0KHQpO1xuICAgICAgaWYgKGkpXG4gICAgICAgIGkucHJlc2VudCA9ICEwO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHMgPSB1KFwic3BhblwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInN5bWJvbF9fdmFsdWVcIixcbiAgICAgICAgICB0ZXh0Q29udGVudDogdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChzKSwgdGhpcy5fY2hpbGRyZW4uc2V0KHQsIG5ldyBSKHRoaXMuZmxvdywgcywge1xuICAgICAgICAgIGFuaW1hdGVJbjogITAsXG4gICAgICAgICAgb25SZW1vdmU6IHRoaXMuX29uQ2hpbGRSZW1vdmUodClcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdDtcbiAgfVxuICBkaWRVcGRhdGUodCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IFwiZGVjaW1hbFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3RoaXMuc2VjdGlvbi5qdXN0aWZ5XSAtIHRbdGhpcy5zZWN0aW9uLmp1c3RpZnldLCBzID0gdGhpcy5fcHJldk9mZnNldCAtIGk7XG4gICAgcyAmJiB0aGlzLmVsLmFuaW1hdGUoe1xuICAgICAgdHJhbnNmb3JtOiBbYHRyYW5zbGF0ZVgoJHtzfXB4KWAsIFwibm9uZVwiXVxuICAgIH0sIHsgLi4udGhpcy5mbG93LnRyYW5zZm9ybVRpbWluZywgY29tcG9zaXRlOiBcImFjY3VtdWxhdGVcIiB9KTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgRCxcbiAgSiBhcyBOLFxuICBHIGFzIFMsXG4gIHEgYXMgYyxcbiAgc3QgYXMgZCxcbiAgbnQgYXMgZixcbiAgQSBhcyBwLFxuICBhdCBhcyByXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/number-flow/dist/lite-BTIaQdTe.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/number-flow/dist/lite.mjs":
/*!************************************************!*\
  !*** ./node_modules/number-flow/dist/lite.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Digit: () => (/* reexport safe */ _lite_BTIaQdTe_mjs__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   canAnimate: () => (/* reexport safe */ _lite_BTIaQdTe_mjs__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   continuous: () => (/* reexport safe */ _plugins_mjs__WEBPACK_IMPORTED_MODULE_1__.continuous),\n/* harmony export */   \"default\": () => (/* reexport safe */ _lite_BTIaQdTe_mjs__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   define: () => (/* reexport safe */ _lite_BTIaQdTe_mjs__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   formatToData: () => (/* reexport safe */ _lite_BTIaQdTe_mjs__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   prefersReducedMotion: () => (/* reexport safe */ _lite_BTIaQdTe_mjs__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   renderInnerHTML: () => (/* reexport safe */ _lite_BTIaQdTe_mjs__WEBPACK_IMPORTED_MODULE_0__.r)\n/* harmony export */ });\n/* harmony import */ var _lite_BTIaQdTe_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lite-BTIaQdTe.mjs */ \"(ssr)/./node_modules/number-flow/dist/lite-BTIaQdTe.mjs\");\n/* harmony import */ var _plugins_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins.mjs */ \"(ssr)/./node_modules/number-flow/dist/plugins.mjs\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnVtYmVyLWZsb3cvZGlzdC9saXRlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTZGO0FBQzdDO0FBVTlDIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9udW1iZXItZmxvdy9kaXN0L2xpdGUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEQgYXMgciwgYyBhcyBvLCBOIGFzIG4sIGQgYXMgcywgZiBhcyB0LCBwIGFzIGYsIHIgYXMgZCB9IGZyb20gXCIuL2xpdGUtQlRJYVFkVGUubWpzXCI7XG5pbXBvcnQgeyBjb250aW51b3VzIGFzIGMgfSBmcm9tIFwiLi9wbHVnaW5zLm1qc1wiO1xuZXhwb3J0IHtcbiAgciBhcyBEaWdpdCxcbiAgbyBhcyBjYW5BbmltYXRlLFxuICBjIGFzIGNvbnRpbnVvdXMsXG4gIG4gYXMgZGVmYXVsdCxcbiAgcyBhcyBkZWZpbmUsXG4gIHQgYXMgZm9ybWF0VG9EYXRhLFxuICBmIGFzIHByZWZlcnNSZWR1Y2VkTW90aW9uLFxuICBkIGFzIHJlbmRlcklubmVySFRNTFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/number-flow/dist/lite.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/number-flow/dist/plugins.mjs":
/*!***************************************************!*\
  !*** ./node_modules/number-flow/dist/plugins.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   continuous: () => (/* binding */ l)\n/* harmony export */ });\nconst f = (e, n) => e == null ? n : n == null ? e : Math.max(e, n), i = /* @__PURE__ */ new WeakMap(), l = {\n  onUpdate(e, n, o) {\n    if (i.set(o, void 0), !o.computedTrend)\n      return;\n    const s = n.integer.concat(n.fraction).filter((t) => t.type === \"integer\" || t.type === \"fraction\"), r = e.integer.concat(e.fraction).filter((t) => t.type === \"integer\" || t.type === \"fraction\"), u = s.find((t) => !r.find((c) => c.pos === t.pos && c.value === t.value)), a = r.find((t) => !s.find((c) => t.pos === c.pos && t.value === c.value));\n    i.set(o, f(u == null ? void 0 : u.pos, a == null ? void 0 : a.pos));\n  },\n  getDelta(e, n, o) {\n    const s = e - n, r = i.get(o.flow);\n    if (!s && r != null && r >= o.pos)\n      return o.length * o.flow.computedTrend;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnVtYmVyLWZsb3cvZGlzdC9wbHVnaW5zLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9udW1iZXItZmxvdy9kaXN0L3BsdWdpbnMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGYgPSAoZSwgbikgPT4gZSA9PSBudWxsID8gbiA6IG4gPT0gbnVsbCA/IGUgOiBNYXRoLm1heChlLCBuKSwgaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBsID0ge1xuICBvblVwZGF0ZShlLCBuLCBvKSB7XG4gICAgaWYgKGkuc2V0KG8sIHZvaWQgMCksICFvLmNvbXB1dGVkVHJlbmQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IG4uaW50ZWdlci5jb25jYXQobi5mcmFjdGlvbikuZmlsdGVyKCh0KSA9PiB0LnR5cGUgPT09IFwiaW50ZWdlclwiIHx8IHQudHlwZSA9PT0gXCJmcmFjdGlvblwiKSwgciA9IGUuaW50ZWdlci5jb25jYXQoZS5mcmFjdGlvbikuZmlsdGVyKCh0KSA9PiB0LnR5cGUgPT09IFwiaW50ZWdlclwiIHx8IHQudHlwZSA9PT0gXCJmcmFjdGlvblwiKSwgdSA9IHMuZmluZCgodCkgPT4gIXIuZmluZCgoYykgPT4gYy5wb3MgPT09IHQucG9zICYmIGMudmFsdWUgPT09IHQudmFsdWUpKSwgYSA9IHIuZmluZCgodCkgPT4gIXMuZmluZCgoYykgPT4gdC5wb3MgPT09IGMucG9zICYmIHQudmFsdWUgPT09IGMudmFsdWUpKTtcbiAgICBpLnNldChvLCBmKHUgPT0gbnVsbCA/IHZvaWQgMCA6IHUucG9zLCBhID09IG51bGwgPyB2b2lkIDAgOiBhLnBvcykpO1xuICB9LFxuICBnZXREZWx0YShlLCBuLCBvKSB7XG4gICAgY29uc3QgcyA9IGUgLSBuLCByID0gaS5nZXQoby5mbG93KTtcbiAgICBpZiAoIXMgJiYgciAhPSBudWxsICYmIHIgPj0gby5wb3MpXG4gICAgICByZXR1cm4gby5sZW5ndGggKiBvLmZsb3cuY29tcHV0ZWRUcmVuZDtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIGwgYXMgY29udGludW91c1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/number-flow/dist/plugins.mjs\n");

/***/ })

};
;